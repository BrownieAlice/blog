<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="theme-color" content="#263238">

<meta name="generator" content="Hugo 0.55.3" />

<link rel="apple-touch-icon" href="https://blog.browniealice.net/images/logo.png">


<link rel="canonical" href="https://blog.browniealice.net/post/i_do_not_know_structured_bindings/">


    
    <link href="//fonts.googleapis.com/css?family=Roboto+Slab:400,700" rel="stylesheet">
    
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>構造化束縛分かってなかった - Alice in the Machine - Blog</title>
    

<meta name="description" content="C&#43;&#43;初心者なので, 誤りなどがあるかもしれません&amp;gt;&amp;lt;; 構造化束縛 C&#43;&#43;17には構造化束縛(Structured bindings)">

<meta property="og:title" content="構造化束縛分かってなかった - Alice in the Machine - Blog">
<meta property="og:type" content="article">
<meta property="og:url" content="https://blog.browniealice.net/post/i_do_not_know_structured_bindings/">
<meta property="og:image" content="https://blog.browniealice.net/images/i_do_not_know_structured_bindings/thumnail.png">
<meta property="og:site_name" content="Alice in the Machine - Blog">
<meta property="og:description" content="C&#43;&#43;初心者なので, 誤りなどがあるかもしれません&amp;gt;&amp;lt;; 構造化束縛 C&#43;&#43;17には構造化束縛(Structured bindings)">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="Alice in the Machine - Blog">
<meta name="twitter:url" content="https://blog.browniealice.net/post/i_do_not_know_structured_bindings/">
<meta name="twitter:title" content="構造化束縛分かってなかった - Alice in the Machine - Blog">
<meta name="twitter:description" content="C&#43;&#43;初心者なので, 誤りなどがあるかもしれません&amp;gt;&amp;lt;; 構造化束縛 C&#43;&#43;17には構造化束縛(Structured bindings)">
<meta name="twitter:image" content="https://blog.browniealice.net/images/i_do_not_know_structured_bindings/thumnail.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https:\/\/blog.browniealice.net\/"
    },
    "headline": "構造化束縛分かってなかった - Alice in the Machine - Blog",
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/blog.browniealice.net\/images\/i_do_not_know_structured_bindings\/thumnail.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2019-01-04T09:46:46JST",
    "dateModified": "2019-01-04T09:46:46JST",
    "author": {
      "@type": "Person",
      "name": "Alice in the Machine - Blog"
    },
    "publisher": {
      "@type": "Organization",
      "name": "Alice in the Machine - Blog",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/blog.browniealice.net\/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "C\x2b\x2b初心者なので, 誤りなどがあるかもしれません\x26gt;\x26lt;; 構造化束縛 C\x2b\x2b17には構造化束縛(Structured bindings)"
  }
</script>


    <style>
      html { font-size: 18px; background-color: rgba(236,239,241,.5);}@media (max-width: 768px) { html { font-size: 15px; }}body { color: #333; font-family: 'Roboto Slab','ヒラギノ角ゴ Pro W3','Hiragino Kaku Gothic Pro',メイリオ,Meiryo,sans-serif; font-feature-settings : "palt"; font-size: inherit; line-height: 1rem; margin: 0; padding: 0;}h1, h2, h3, h4, h5 ,h6 { font-size: 1rem; font-weight: 700; line-height: 1rem; margin: 0;}hr { border: 0; border-top: 1px dashed #cfd8dc; margin: 1rem 0;}p { margin: 0; line-height: 1rem;}a { color: #2196f3; text-decoration: none; transition-duration: .3s;}ul, ol { margin: 0; padding: 0;}table { border-collapse: collapse;}th, td { font-size: .8rem; padding: .5rem;}tr { border-bottom: 1px dashed #ddd;}/* Layouts */main,aside { display: block;}main { padding: 1rem 0 3rem 0; }aside.h { padding: 3rem 0; }main.f,aside.f { background-color: #333; border-top: 2px dashed #fff; border-bottom: 2px dashed #fff;}.l-container { position: relative; max-width: 68rem; margin: 0 auto; padding: 0 1rem;}.l-container.thin { max-width: 44rem;}.l-header { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); padding: 1rem 0; text-align: center;}.l-header .description { margin-top: .5rem; font-size: .8rem;}.l-footer { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); font-size: .6rem; font-weight: 700; padding: 1rem 0;}@media (max-width: 768px) { .l-sidebar { margin-top: 4rem; }}.mrow { margin: 0 -1rem; overflow: hidden;}.mcol { box-sizing: border-box; float: left; padding: 0 1rem;}.c6 { width: 50%; }.c4 { width: 33.26323833%; }.c8 { width: 66.66666%; }@media (max-width: 768px) { .mcol { width: 100%; float: none; }}.logo a { font-size: 1.4rem; line-height: 1.5rem; font-weight: 700; color: #333;}.articles { margin: -1rem 0; margin-bottom: 1rem;}.articles.sm { margin: -.5rem 0; margin-bottom: 0;}article { border-radius: 4px; overflow: hidden;}article.li { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); height: 20rem; overflow: hidden; margin: 1rem 0;}article.li > a { display: block; color: #333;}article.li .inner { padding: 1rem;}article.li .thumb { height: 8rem;}article.li .title { color: #333; font-size: 1.2rem; line-height: 1.5rem; margin-bottom: .5rem;}article.li .summary { font-size: .8rem; height: 6rem; overflow: hidden; margin-top: 1rem;}article.li .summary::after { content: '...';}article.lism { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); margin: .5rem 0;}article.lism::after { content: ''; display: block; clear: both;}article.lism > a { display: block; color: #333;}article.lism .inner { display: table-cell; vertical-align: middle; height: 5rem; padding: 0 .75rem;}article.lism .thumb { width: 5rem; height: 5rem; float: left;}article.lism .title { font-weight: 700; font-size: .8rem; margin-bottom: .25rem;}article.sn { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); margin-bottom: 1rem;}article.sn .thumb { height: 20rem;}@media (max-width: 768px) { article.sn .thumb { height: 10rem; }}article.sn > .article-header,article.sn > .article-body,article.sn .article-footer { padding: 2rem;}article.sn > .article-body { padding: 0 2rem;}@media (max-width: 768px) { article.sn > .article-header, article.sn > .article-body, article.sn .article-footer { padding: 1rem; } article.sn > .article-body { padding: 0 1rem; }}article.sn > .article-header .title { font-size: 1.8rem; line-height: 2rem; margin-bottom: .5rem;}@media (max-width: 768px) { article.sn > .article-header .title { font-size: 1.4rem; line-height: 1.5rem; }}article.sn > .article-header .facts { margin-bottom: 1rem;}article.sn > .article-body { margin-bottom: 1.5rem;}article.sn > .article-body h2 { border-bottom: .25rem solid #333; font-size: 1.2rem; line-height: 1.5rem; margin: 1.5rem 0; padding: .5rem 0;}article.sn > .article-body h3 { border-left: .5rem solid #333; line-height: 1.5rem; margin: 1.5rem 0; padding: .125rem .5rem;}article.sn > .article-body ul,article.sn > .article-body ol { margin: 1.5rem 0; padding-left: 1.5rem;}article.sn > .article-body li { padding-bottom: .5rem; line-height: 1.5rem;}article.sn > .article-body li:last-child { padding-bottom: 0;}article.sn > .article-body p { margin: 1rem 0; line-height: 1.5rem;}article.sn > .article-body strong,article.sn > .article-body em { font-style: normal; font-weight: 700;}article.sn > .article-body strong { box-shadow: 0 -.5rem 0 0 #ffc107 inset;}article.sn > .article-body em { color: #8bc34a;}article.sn > .article-body code,article.sn > .article-body pre { font-family: Menlo, Consolas, monospace; font-size: .7rem;}article.sn > .article-body pre { background-color: #333; color: #fff; line-height: 1rem; margin: 1.5rem -2rem; overflow: auto;}@media (max-width: 768px) { article.sn > .article-body pre { margin: 1.5rem -1rem; }}article.sn > .article-body pre > code { display: block; padding: 1rem 2rem;}@media (max-width: 768px) { article.sn > .article-body pre > code { padding: 1rem; }}article.sn > .article-body p code { background-color: #eceff1; color: #333; border-radius: 4px; margin: 0 .25rem; padding: .375rem; white-space: nowrap;}article.sn > .article-body blockquote { position: relative; border-left: .25rem solid #333; font-size: .8rem; padding: .125rem 1rem; margin: 1.5rem 0;}@media (max-width: 768px) { article.sn > .article-body blockquote { font-size: 1rem; }}article.sn > .article-body blockquote p { margin: .5rem 0; line-height: 1rem;}article.sn > .article-body figure { margin: 1.5rem 0;}article.sn > .article-body img,article.sn > .article-body figure img,article.sn > .article-body figure amp-img { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); max-width: 100%;}article.sn > .article-body figcaption { color: #cfd8dc; font-size: .8rem; font-weight: 700; margin-top: .5rem;}.facts li { display: inline; font-size: .8rem; margin-right: 1rem;}.facts i { color: #cfd8dc; margin-right: .5em;}.facts.sm li { font-size: .7rem;}.sections.sidebar { margin: -1rem 0;}.sections.footer { margin: -1rem 0;}section.sidebar { margin: 2rem 0;}section.sidebar > header { font-size: .8rem; font-weight: 700; letter-spacing: 4px; text-align: center; margin: 1.5rem 0;}section.footer { margin: 1rem 0;}section.footer > header { font-size: .8rem; margin: .5rem 0;}section.footer > header::before { content: "- ";}section.footer > header a { font-weight: 700; color: #333; text-decoration: underline;}.terms { margin: -.25rem;}.terms li { display: inline-block;}.terms a { display: block; float: left; background-color: #333; border-radius: 4px; color: #fff; font-size: .7rem; margin: .25rem; padding: 0 .75rem; line-height: 1.75rem;}.paging { text-align: center; padding: 1rem 0;}.paging a { display: inline-block; background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); border-radius: 4px; color: #333; padding: 0 1rem; line-height: 3rem;}.page-title { text-align: center; margin: 1rem 0;}.page-title::after { content: ''; display: block; border-bottom: .25rem solid #333; width: 3rem; margin: 1.5rem auto;}.page-title > .title { font-size: 1.2rem; line-height: 1.5rem;}/* Parts:breadcrumb */.crumb ol { text-overflow: ellipsis; color: #cfd8dc; white-space: nowrap; overflow: hidden;}.crumb li { display: inline; font-size: .8rem;}.crumb li::after { content: '›'; margin: 0 .25rem 0 .5rem;}.crumb li:last-child::after { content: '';}.crumb a { color: #cfd8dc;}.crumb i { margin-right: .5em;}.share { padding: 0;}.share a { display: inline-block; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); min-width: 1rem; height: 2rem; border-radius: 4px; color: #333; font-size: .8rem; font-weight: 700; line-height: 2rem; text-align: center; padding: 0 .5rem;}.adj article.lism { margin-bottom: 1rem;}.adj header { font-weight: 700; font-size: .8rem;}.toc { padding: 0 2rem;}@media (max-width: 768px) { .toc { padding: 0 1rem; }}.toc { margin: 1rem 0;}.toc nav>ul { background-color: #eceff1; border-radius: 4px; display: inline-block; font-size: .8rem; padding: .5rem 1rem; word-break: break-all; list-style: none;}.toc ul { padding: 0;}.toc ul ul { padding-left: 1rem;}.toc ul ul ul { padding-left: 1rem;}.toc li { color: #90a4ae;}.toc ul ul>li { font-weight: 700; margin: .5rem 0; list-style-type: decimal;}.toc ul ul ul>li { list-style-type: disc; font-weight: 500;}.author { background-color: #fff; box-shadow: 0 0 0 1px rgba(63,63,68,.05), 0 1px 3px rgba(63,63,68,.1), 0 1px 2px rgba(0,0,0,.05); padding: 1rem; border-radius: 4px; text-align: center;}.author .author-thumb { margin: 0 auto 1rem; width: 6rem; height: 6rem; border-radius: 50%; background-color: #eceff1; background-size: cover; background-position: center;}.author .author-name { margin-bottom: .5rem; font-weight: 700;}.author .author-facts { margin-bottom: 1rem;}.author .author-facts li { display: inline;}.author .author-facts li a { display: inline-block; background-color: #eceff1; width: 1.75rem; height: 1.75rem; line-height: 1.75rem; text-align: center; color: #333; font-size: .8rem; border-radius: 2px;}.author .author-facts li a:hover { color: #fff; background-color: #333;}.author .author-description { text-align: left; font-size: .8rem;}.author .author-description p { margin: .5rem 0;}.thumb { background-image: url(https://blog.browniealice.net/images/default.jpg); background-size: cover; background-position: center;}.thumb-7e4990fbdf3e6b12e93c5cec55613f2b { background-image: url(https://blog.browniealice.net/images/kougyou/thumnail.png);}.thumb-c7eb02b8f2905cb2e0b765219ebd3fcd { background-image: url(https://blog.browniealice.net/images/i_do_not_know_structured_bindings/thumnail.png);}.thumb-ccfa4171f088fe2977fc00a57b5f49b1 { background-image: url(https://blog.browniealice.net/images/tuple_iterate/thumnail.png);}.thumb-a955fd2306ee228d5d022fd07d759b31 { background-image: url(https://blog.browniealice.net/images/arch_esp32_arduino_IDE/esp32.JPG);}.thumb-984758970a7a9b13be2dda2245b55bc0 { background-image: url(https://blog.browniealice.net/images/ros-lunar_on_arch/rqt_graph.png);}.thumb-affad8b4c9b1dc4313a19d1a3dba7cea { background-image: url(https://blog.browniealice.net/images/latex_transpose/transpose.svg);}.thumb-196f35a41629edee268871118953dad4 { background-image: url(https://blog.browniealice.net/images/rviz_invalid_quaternion/thumnail.png);}.thumb-f7718d298b384f1f0a1853ab9f589a3c { background-image: url(https://blog.browniealice.net/images/how_to_use_urg/rosgraph.svg);}.thumb-a2cb24d7c92e2209de12daee99c91cee { background-image: url(https://blog.browniealice.net/images/mail_server/mail.png);}.thumb-8c1ed8211c7d5c668c160c15dcf27dd3 { background-image: url(https://blog.browniealice.net/images/build_server/https.png);}.thumb-ecf530c4e52cb890940bc1c0d87054cd { background-image: url(https://blog.browniealice.net/images/yamanashi_camp/water_mill.JPG);}.thumb-ce5392764e34b526da684a662c42211a { background-image: url(https://blog.browniealice.net/images/2017ABUrobocon/miyabi.JPG);}.thumb-cf49c28371ec07ddf2b3f0accac0c7ea { background-image: url(https://blog.browniealice.net/images/visit-kanazawa-3day/hill.JPG);}.thumb-90d8043764845801f2f7c82539db3f8b { background-image: url(https://blog.browniealice.net/images/visit-kanazawa-2day/hill.JPG);}.thumb-236b424b8f689db5bbba340e66b53f1c { background-image: url(https://blog.browniealice.net/images/wiki_renewal/wiki.png);}.thumb-271265f27807d95cc604bb34bcd7012c { background-image: url(https://blog.browniealice.net/images/visit-kanazawa-1day/kanazawa_station.JPG);}.thumb-2b737af9c85e9f92c8be188fd3ec1c90 { background-image: url(https://blog.browniealice.net/images/disqus_introduce/icon.svg);}
      
      
      
    </style>
  </head>

  <body>
    
    
    

    <header class="l-header">
      <div class="l-container">
        <div class="logo">
          <a href="https://blog.browniealice.net/">Alice in the Machine - Blog</a>
        </div>
        
<div class="description">
  エンジニアを目指したいへっぽこ学生の技術系ブログ.
</div>


      </div>
    </header>

    <main>
      <div class="l-container">
        
<div class="mrow">
  <div class="mcol c8">

    <article class="sn">

  <div class="thumb thumb-c7eb02b8f2905cb2e0b765219ebd3fcd"></div>

  <header class="article-header">
    <h1 class="title">構造化束縛分かってなかった</h1>

    <ul class="facts">
      <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-01-04T09:46:46JST">2019-01-04</time></li>
      <li><i class="fa fa-bookmark" aria-hidden="true"></i><a href="https://blog.browniealice.net/post/">POST</a></li>
      
    </ul>

    <aside class="share">
  <a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&title=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f" title="はてなブックマーク" class="ht" target="_blank" rel="nofollow">B!</a>
  <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&text=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f&tw_p=tweetbutton" title="Twitterでシェア" class="tw" target="_blank" rel="nofollow"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  <a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&t=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f" title="Facebookでシェア" class="fb" target="_blank" rel="nofollow"><i class="fa fa-facebook" aria-hidden="true"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f" title="Google Plusでシェア" class="gp" target="_blank" rel="nofollow"><i class="fa fa-google-plus" aria-hidden="true"></i></a>
  <a href="http://getpocket.com/edit?url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&title=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f" title="Pocketに保存" class="pk" target="_blank" rel="nofollow"><i class="fa fa-get-pocket" aria-hidden="true"></i></a>
  <a href="http://line.me/R/msg/text/?%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f" title="LINEでシェア" class="ln" target="_blank" rel="nofollow">LINE</a>
</aside>

  </header>

  
  <div class="toc">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#構造化束縛">構造化束縛</a></li>
<li><a href="#型推論">型推論</a>
<ul>
<li><a href="#auto-による型推論"><code>auto</code>による型推論</a></li>
<li><a href="#decltype-auto-による型推論"><code>decltype(auto)</code>による型推論</a></li>
</ul></li>
<li><a href="#構造化束縛によって決まる型">構造化束縛によって決まる型</a></li>
<li><a href="#構造化束縛のその他の性質">構造化束縛のその他の性質</a>
<ul>
<li><a href="#std-tuple"><code>std::tuple</code></a></li>
<li><a href="#構造化束縛の構文">構造化束縛の構文</a></li>
</ul></li>
<li><a href="#まとめ">まとめ</a></li>
<li><a href="#参考文献">参考文献</a></li>
</ul></li>
</ul>
</nav>
  </div>
  

  <div class="article-body">

<p>C++初心者なので, 誤りなどがあるかもしれません&gt;&lt;;</p>

<h2 id="構造化束縛">構造化束縛</h2>

<p>C++17には構造化束縛(Structured bindings)という機能が存在します<sup class="footnote-ref" id="fnref:0"><a href="#fn:0">1</a></sup>.<br />
これは, 配列<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">2</a></sup>や<code>std::tuple</code><sup class="footnote-ref" id="fnref:2"><a href="#fn:2">3</a></sup>の各要素, クラス<sup class="footnote-ref" id="fnref:union"><a href="#fn:union">4</a></sup>のpublicな<sup class="footnote-ref" id="fnref:3"><a href="#fn:3">5</a></sup>各メンバ変数を分解して受け取る機能です.
下にサンプルコードを示します.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;tuple&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">struct</span> Hoge {
  <span style="color:#66d9ef">int</span> i;
  <span style="color:#66d9ef">double</span> d;
  <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> u;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>};
  <span style="color:#66d9ef">auto</span> [a1, a2, a3] <span style="color:#f92672">=</span> a;
  <span style="color:#75715e">// 配列の各要素をを構造化束縛宣言で取り出す.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// a1 == 1, a2 == 3, a3 == 5.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">auto</span> t <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_tuple(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;po&#34;</span>, <span style="color:#ae81ff">5.0</span>);
  <span style="color:#66d9ef">auto</span> [t1, t2, t3] <span style="color:#f92672">=</span> t;
  <span style="color:#75715e">// std::tupleの各要素を構造化束縛宣言で取り出す.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// t1 == 1, t2 == &#34;po&#34;, t3 == 5.0.
</span><span style="color:#75715e"></span>
  Hoge h <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">5.0</span>, <span style="color:#ae81ff">100</span>};
  <span style="color:#66d9ef">auto</span> [h1, h2, h3] <span style="color:#f92672">=</span> h;
  <span style="color:#75715e">// 構造体の各publicメンバ変数を構造化束縛宣言で取り出す.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// h1 == 1, h2 == 5.0, h3 == 100.
</span><span style="color:#75715e"></span>}
</code></pre></div>
<p>最初は<code>int</code>型の配列の各要素を, 2番目は<code>std::tuple</code>の各要素を, 3番目は<code>Hoge</code>構造体のpublicな各メンバ変数を分解して受け取っています.<br />
構造化束縛では<code>auto</code>キーワードを使い, 分解されたそれぞれの変数の型は明示的には宣言しません.
そして, 分解して定義されたそれぞれの変数の型が私の直感とは少し異なっていたというお話です.</p>

<h2 id="型推論">型推論</h2>

<p>C++11からは<code>auto</code>キーワードを使い, 型推論を用いた変数宣言が出来るようになりました.<br />
ここでは本筋に関係あるところだけ, 厳密には間違っているような雑な説明だけします.
詳細な話は<a href="https://www.oreilly.co.jp/books/9784873117362/">Effective Modern C++</a>などを参考にすると良いかと思います.</p>

<h3 id="auto-による型推論"><code>auto</code>による型推論</h3>

<p>ざっくりというと<code>auto 変数名 = 式</code><sup class="footnote-ref" id="fnref:4"><a href="#fn:4">6</a></sup>という変数宣言の場合, この変数の型は式の型から参照と<code>const</code>と<code>volatile</code>が取り払われたものになります.<br />
実際に型推論させた変数の型を<a href="http://boostorg.github.io/type_index/">Boost.Typeindex</a>を用いて型情報を調べてみましょう.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/type_index.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> output_types() {
  <span style="color:#75715e">//  T1の型とT2の型を出力する.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//      T1の型, T2の型
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//  のように出力される.
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> boost<span style="color:#f92672">::</span>typeindex<span style="color:#f92672">::</span>type_id_with_cvr<span style="color:#f92672">&lt;</span>T1<span style="color:#f92672">&gt;</span>().pretty_name()
	    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, &#34;</span>
	    <span style="color:#f92672">&lt;&lt;</span> boost<span style="color:#f92672">::</span>typeindex<span style="color:#f92672">::</span>type_id_with_cvr<span style="color:#f92672">&lt;</span>T2<span style="color:#f92672">&gt;</span>().pretty_name()
	    <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> main() {
  <span style="color:#66d9ef">int</span> a1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">auto</span> b1 <span style="color:#f92672">=</span> a1;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a1), <span style="color:#66d9ef">decltype</span>(b1)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a1はint型, b1もint型.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> a2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">auto</span> b2 <span style="color:#f92672">=</span> a2;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a2), <span style="color:#66d9ef">decltype</span>(b2)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a2はconst double型, b2はdouble型.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">int</span> <span style="color:#f92672">&amp;</span>a3 <span style="color:#f92672">=</span> a1;
  <span style="color:#66d9ef">auto</span> b3 <span style="color:#f92672">=</span> a3;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a3), <span style="color:#66d9ef">decltype</span>(b3)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a3はint&amp;型, b3はint型.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>a4 <span style="color:#f92672">=</span> a2;
  <span style="color:#66d9ef">auto</span> b4 <span style="color:#f92672">=</span> a4;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a4), <span style="color:#66d9ef">decltype</span>(b4)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a4はconst double&amp;型, b4はdouble型.
</span><span style="color:#75715e"></span>}
</code></pre></div>
<p>出力</p>

<pre><code>int, int
double const, double
int&amp;, int
double const&amp;, double
</code></pre>

<p>出力を見ると, 型推論を用いて宣言した<code>b1</code>~<code>b4</code>の型はたしかに参照と<code>const</code>が取れているのがわかるかと思います.<br />
きちんとした話をすると, 推論規則は3種類に場合分けできてユニバーサル参照のときは云々……となると思うのですが, 厳密な話は先に上げた本なり規格書なりを参考にしてください.</p>

<h3 id="decltype-auto-による型推論"><code>decltype(auto)</code>による型推論</h3>

<p><code>decltype(auto) 変数名 = 式</code>という形で型推論を行うこともできます.<br />
この場合, <code>auto</code>キーワードによる推論ではあった参照や<code>const</code>が取り払われる振る舞いがなくなります.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/type_index.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> output_types() {
  <span style="color:#75715e">//  T1の型とT2の型を出力する.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//      T1の型, T2の型
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//  のように出力される.
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> boost<span style="color:#f92672">::</span>typeindex<span style="color:#f92672">::</span>type_id_with_cvr<span style="color:#f92672">&lt;</span>T1<span style="color:#f92672">&gt;</span>().pretty_name()
	    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, &#34;</span>
	    <span style="color:#f92672">&lt;&lt;</span> boost<span style="color:#f92672">::</span>typeindex<span style="color:#f92672">::</span>type_id_with_cvr<span style="color:#f92672">&lt;</span>T2<span style="color:#f92672">&gt;</span>().pretty_name()
	    <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">int</span> main() {
  <span style="color:#66d9ef">double</span> a5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
  <span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) b5 <span style="color:#f92672">=</span> a5;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a5), <span style="color:#66d9ef">decltype</span>(b5)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a5はdouble型, b5もdouble型.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a6 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) b6 <span style="color:#f92672">=</span> a6;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a6), <span style="color:#66d9ef">decltype</span>(b6)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a6はconst int型, b6もconst int型.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>a7 <span style="color:#f92672">=</span> a5;
  <span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) b7 <span style="color:#f92672">=</span> a7;
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a7), <span style="color:#66d9ef">decltype</span>(b7)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a7はconst double&amp;型, b7もconst double&amp;型.
</span><span style="color:#75715e"></span>}
</code></pre></div>
<p>出力</p>

<pre><code>double, double
int const, int const
double const&amp;, double const&amp;
</code></pre>

<p><code>decltype(auto)</code>で型推論させた変数の型は, 初期化に用いた変数の型と同じ型になっているのがわかります.<br />
この形式の型推論も丸括弧をつけると振る舞いが変わったりするそうなのですが, その辺の話はよくわかりません&gt;&lt;;</p>

<h2 id="構造化束縛によって決まる型">構造化束縛によって決まる型</h2>

<p>クラスのpublicな各メンバ変数を構造化束縛で分解して受け取った時, どのような型になるのでしょうか.<br />
構造化束縛は<code>auto</code>キーワードを使って宣言するので直感的には, 各メンバ変数を<code>auto</code>で型推論した型になりそうです.<br />
しかし, C++17の規格書相当の<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">N4659</a>の11.5.4項を見てみると, 分解されたそれぞれの変数の型は元のクラスで定義された型になる<sup class="footnote-ref" id="fnref:type"><a href="#fn:type">7</a></sup>と読み取れます.<br />
つまり, <code>auto</code>を用いた型推論の型になるわけではないということです.
具体的にどのような差があるか見ていきましょう.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;boost/type_index.hpp&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T1, <span style="color:#66d9ef">typename</span> T2<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> output_types() {
  <span style="color:#75715e">//  T1の型とT2の型を出力する.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//      T1の型, T2の型
</span><span style="color:#75715e"></span>  <span style="color:#75715e">//  のように出力される.
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> boost<span style="color:#f92672">::</span>typeindex<span style="color:#f92672">::</span>type_id_with_cvr<span style="color:#f92672">&lt;</span>T1<span style="color:#f92672">&gt;</span>().pretty_name()
	    <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;, &#34;</span>
	    <span style="color:#f92672">&lt;&lt;</span> boost<span style="color:#f92672">::</span>typeindex<span style="color:#f92672">::</span>type_id_with_cvr<span style="color:#f92672">&lt;</span>T2<span style="color:#f92672">&gt;</span>().pretty_name()
	    <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}

<span style="color:#66d9ef">struct</span> Hoge {
  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a;
  <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>b;
  <span style="color:#75715e">// const int型, double&amp;型のメンバ変数.
</span><span style="color:#75715e"></span>  Hoge(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">double</span> <span style="color:#f92672">&amp;</span>b)<span style="color:#f92672">:</span> a(a), b(b){
 }
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.14</span>;
  Hoge h(<span style="color:#ae81ff">1</span>, d);

  <span style="color:#66d9ef">auto</span> a1 <span style="color:#f92672">=</span> h.a;
  <span style="color:#66d9ef">auto</span> a2 <span style="color:#f92672">=</span> h.b;
  <span style="color:#75715e">// 各要素を直接型推論して受け取る場合.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">auto</span> [b1, b2] <span style="color:#f92672">=</span> h;
  <span style="color:#75715e">// 構造化束縛で受け取る場合.
</span><span style="color:#75715e"></span>
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a1), <span style="color:#66d9ef">decltype</span>(b1)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a1はint型, b1はconst int型.
</span><span style="color:#75715e"></span>  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(a2), <span style="color:#66d9ef">decltype</span>(b2)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// a2はdouble型, b2はdouble&amp;型.
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) c1 <span style="color:#f92672">=</span> h.a;
  <span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) c2 <span style="color:#f92672">=</span> h.b;
  <span style="color:#75715e">// 各要素をdecltype(auto)で直接型推論して受け取る場合.
</span><span style="color:#75715e"></span>
  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(c1), <span style="color:#66d9ef">decltype</span>(b1)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// c1はconst int型, b1もconst int型.
</span><span style="color:#75715e"></span>  output_types<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">decltype</span>(c2), <span style="color:#66d9ef">decltype</span>(b2)<span style="color:#f92672">&gt;</span>();
  <span style="color:#75715e">// c2はdouble&amp;型, b2もdouble&amp;型.
</span><span style="color:#75715e"></span>}
</code></pre></div>
<p>出力</p>

<pre><code>int, int const
double, double&amp;
int const, int const
double&amp;, double&amp;
</code></pre>

<p><code>Hoge</code>構造体は, <code>const int</code>型のメンバ変数<code>a</code>と<code>double&amp;</code>型のメンバ変数<code>b</code>を持っています.<br />
直接メンバ変数にアクセスして型推論を用いて変数の初期化を行うと, <code>const</code>や参照が取り外され, それぞれの変数の型は<code>int</code>と<code>double</code>になります.<br />
一方で構造化束縛で変数を宣言した場合, それぞれの変数の型はメンバ変数の型と同じ<code>const int</code>型と<code>double&amp;</code>型になります.
この性質は<code>decltype(auto)</code>を用いて型推論を行い変数宣言した場合と似ています<sup class="footnote-ref" id="fnref:decl"><a href="#fn:decl">8</a></sup>.</p>

<h2 id="構造化束縛のその他の性質">構造化束縛のその他の性質</h2>

<h3 id="std-tuple"><code>std::tuple</code></h3>

<p><code>std::tuple</code>を構造化束縛により分解して受け取った場合の型の決定規則は上述したものとは違います.<br />
分解しようとする型<code>E</code>に対し, i番目に受け取った変数の型は<code>std::tuple_element&lt;i, E&gt;::type</code>で決まるようです.
この場合も, <code>auto</code>の型推論ではあった参照や<code>const</code>外しの操作が行われないことがわかります.</p>

<h3 id="構造化束縛の構文">構造化束縛の構文</h3>

<p>構造化束縛の構文は以下のようになります(optはオプション).<br />
<em>attribute-specifier-seq</em>(opt)  <em>decl-specifier-seq</em>  <em>ref-qualifier</em>(opt)  [<em>identifier-list</em>]  <em>initializer</em>;<br />
正直これだとなにがなんだかわからないと思いますが, この構文の中の <em>decl-specifier-seq</em> が今まで<code>auto</code>キーワードを用いてた部分になります.<sup class="footnote-ref" id="fnref:spec"><a href="#fn:spec">9</a></sup><br />
<em>decl-specifier-seq</em> は型指定子(<em>type-specifier</em>)を含むのですが, 構造化束縛の際には型指定子として<code>auto</code>しか用いてはいけないようです.
なので</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-C++" data-lang="C++"><span style="color:#66d9ef">decltype</span>(<span style="color:#66d9ef">auto</span>) [a1, a2, a3] <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>make_tuple(<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1.3</span>, <span style="color:#e6db74">&#34;po&#34;</span>);
</code></pre></div>
<p>は構文エラーになります.
<code>decltype(auto)</code>に似た規則で型が定まるのに, <code>decltype(auto)</code>と書いてはいけないんですね….</p>

<h2 id="まとめ">まとめ</h2>

<p>構造化束縛はC++17の便利な機能.<br />
しかし, <code>auto</code>キーワードを使って宣言するのに, それぞれの型は<code>auto</code>キーワードを使った型推論とは異なった規則で定まる.
とくに参照や<code>const</code>, <code>volatile</code>がある場合は注意しないといけない.</p>

<h2 id="参考文献">参考文献</h2>

<ul>
<li><a href="https://www.oreilly.co.jp/books/9784873117362/">Effective Modern C++ &ndash;C++11/14プログラムを進化させる42項目</a></li>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf">Working Draft, Standard for Programming Language C++ N4659</a></li>
<li><a href="https://ja.cppreference.com/w/">cppreference.com</a></li>
<li><a href="https://ezoeryou.github.io/cpp17book/">江添亮の詳説C++17</a></li>
</ul>
<div class="footnotes">

<hr />

<ol>
<li id="fn:0">構造化束縛宣言(Structured bindings declarations)のほうが正しいのかもしれませんが, 日本語だとほとんど構造化束縛と呼ばれているので本記事でもこのように記載します.
 <a class="footnote-return" href="#fnref:0"><sup>[return]</sup></a></li>
<li id="fn:1"><code>std::array</code>ではなくC言語スタイルの配列の方です.
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
<li id="fn:2"><code>std::tuple</code>に似た機能を持つクラスも対象です. 雑に言うと<code>std::tuple_size&lt;T&gt;</code>が使えたり, <code>get&lt;i&gt;</code>メンバ関数か<code>std::get&lt;i&gt;</code>で各要素が取り出せるものです. <code>std::pair</code>や<code>std::shared_ptr</code>(C++20以降)などが当てはまります.
 <a class="footnote-return" href="#fnref:2"><sup>[return]</sup></a></li>
<li id="fn:union">無名共用体(anonymous union)メンバがなく, 全ての非staticなメンバ変数がpublicである(C++17の場合)もしくは…みたいな条件があります.
 <a class="footnote-return" href="#fnref:union"><sup>[return]</sup></a></li>
<li id="fn:3">C++20からは, publicなメンバ変数である必要はなくなるようです(<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/n4791.pdf">N4761</a> 9.5.5項).
 <a class="footnote-return" href="#fnref:3"><sup>[return]</sup></a></li>
<li id="fn:4">ここで考えているのはちゃんと書くと, auto <em>identifer</em> = <em>assignment-expression</em> という形式ものです(多分).
 <a class="footnote-return" href="#fnref:4"><sup>[return]</sup></a></li>
<li id="fn:type">正確には, 構造化束縛の際に<code>const</code>や<code>volatile</code>や参照修飾子を用いて宣言しているならこれらも反映した型になります.
 <a class="footnote-return" href="#fnref:type"><sup>[return]</sup></a></li>
<li id="fn:decl">どんな状況でも各要素を<code>decltype(auto)</code>で型推論させて受け取った場合と同じになる, と言い切っていいのかどうかは(知識不足なので)よくわかりません.
 <a class="footnote-return" href="#fnref:decl"><sup>[return]</sup></a></li>
<li id="fn:spec"><code>const auto</code>や<code>auto &amp;</code>なども <em>decl-specifier-seq</em> に相当します.
 <a class="footnote-return" href="#fnref:spec"><sup>[return]</sup></a></li>
</ol>
</div>
</div>

  <footer class="article-footer">

    <aside class="share">
  <a href="http://b.hatena.ne.jp/add?mode=confirm&url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&title=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f" title="はてなブックマーク" class="ht" target="_blank" rel="nofollow">B!</a>
  <a href="http://twitter.com/intent/tweet?url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&text=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f&tw_p=tweetbutton" title="Twitterでシェア" class="tw" target="_blank" rel="nofollow"><i class="fa fa-twitter" aria-hidden="true"></i></a>
  <a href="http://www.facebook.com/sharer.php?u=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&t=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f" title="Facebookでシェア" class="fb" target="_blank" rel="nofollow"><i class="fa fa-facebook" aria-hidden="true"></i></a>
  <a href="https://plus.google.com/share?url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f" title="Google Plusでシェア" class="gp" target="_blank" rel="nofollow"><i class="fa fa-google-plus" aria-hidden="true"></i></a>
  <a href="http://getpocket.com/edit?url=https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f&title=%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f" title="Pocketに保存" class="pk" target="_blank" rel="nofollow"><i class="fa fa-get-pocket" aria-hidden="true"></i></a>
  <a href="http://line.me/R/msg/text/?%e6%a7%8b%e9%80%a0%e5%8c%96%e6%9d%9f%e7%b8%9b%e5%88%86%e3%81%8b%e3%81%a3%e3%81%a6%e3%81%aa%e3%81%8b%e3%81%a3%e3%81%9f https%3a%2f%2fblog.browniealice.net%2fpost%2fi_do_not_know_structured_bindings%2f" title="LINEでシェア" class="ln" target="_blank" rel="nofollow">LINE</a>
</aside>


    <section class="footer">
      <div>
        <nav class="crumb">
          <ol>
            <li><a href="https://blog.browniealice.net/"><i class="fa fa-home" aria-hidden="true"></i>TOP</a></li>
            
            <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="https://blog.browniealice.net/post/" itemprop="url"><span itemprop="title">POST</span></a></li>
            
            <li class="active">構造化束縛分かってなかった</li>
          </ol>
        </nav>
      </div>
    </section>

    
    
    
    <section class="footer">
      <header>
        <a href="https://blog.browniealice.net/categories/">CATEGORIES</a>
      </header>
      <div>
        <ul class="terms">
          
          <li><a href="https://blog.browniealice.net/categories/technote/">TechNote</a></li>
          
        </ul>
      </div>
    </section>
    
    
    
    
    
    <section class="footer">
      <header>
        <a href="https://blog.browniealice.net/tags/">TAGS</a>
      </header>
      <div>
        <ul class="terms">
          
          <li><a href="https://blog.browniealice.net/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
          
        </ul>
      </div>
    </section>
    
    
  </footer>

</article>


    <div class="adj">
      <div class="mrow">
        
        <div class="mcol c6">
          <header>Previous Article</header>
          <article class="lism">
  <a href="https://blog.browniealice.net/post/tuple_iterate/">
    <div class="thumb thumb-ccfa4171f088fe2977fc00a57b5f49b1"></div>

    <div class="inner">
      <div class="title">std::tupleの全要素の走査</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-12-29T04:24:53JST">2018-12-29</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

        </div>
        
        
        <div class="mcol c6">
          <header>Next Article</header>
          <article class="lism">
  <a href="https://blog.browniealice.net/post/kougyou/">
    <div class="thumb thumb-7e4990fbdf3e6b12e93c5cec55613f2b"></div>

    <div class="inner">
      <div class="title">工業の2文字の真実</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-03-31T20:32:56JST">2019-03-31</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

        </div>
        
      </div>
    </div>

    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "alice-in-the-machine-blog" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
  </div>
  <div class="mcol c4">
    <aside class="l-sidebar">

  <div class="sections sidebar">
    
<section class="sidebar">
  <header>AUTHOR</header>
  <div>
    <div class="author">
      
      <div class="author-thumb" style="background-image: url(https://blog.browniealice.net/images/author.png);"></div>
      
      <div class="author-name">BrownieAlice</div>
      <ul class="author-facts">
        
        
        <li><a href="https://github.com/BrownieAlice" rel="nofollow" target="_blank"><i class="fa fa-github" aria-hidden="true"></i></a></li>
      </ul>
      <div class="author-description">  <div align="center">
  工業大学に通う大学院生. <br>
  ロボコンに参加したことがあったり? <br>
  <a href="https://blog.browniealice.net">Blog</a> /
  <a href="https://wiki.browniealice.net">wiki</a> /
  <a href="https://github.com/BrownieAlice/blog.git">Repository</a>
  </div></div>
    </div>
  </div>
</section>


    <section class="sidebar">
  <header>LATESTS</header>
  <div>
    <div class="articles sm">
      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/internship2019winter/">
    <div class="thumb thumb-b939074cfc7c8b59d6ab3b905a2ae4f4"></div>

    <div class="inner">
      <div class="title">大企業の技術系インターンシップに参加した</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-03-31T21:28:47JST">2019-03-31</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/kougyou/">
    <div class="thumb thumb-7e4990fbdf3e6b12e93c5cec55613f2b"></div>

    <div class="inner">
      <div class="title">工業の2文字の真実</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-03-31T20:32:56JST">2019-03-31</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/i_do_not_know_structured_bindings/">
    <div class="thumb thumb-c7eb02b8f2905cb2e0b765219ebd3fcd"></div>

    <div class="inner">
      <div class="title">構造化束縛分かってなかった</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2019-01-04T09:46:46JST">2019-01-04</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/tuple_iterate/">
    <div class="thumb thumb-ccfa4171f088fe2977fc00a57b5f49b1"></div>

    <div class="inner">
      <div class="title">std::tupleの全要素の走査</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-12-29T04:24:53JST">2018-12-29</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/arch_esp32_arduino_ide/">
    <div class="thumb thumb-a955fd2306ee228d5d022fd07d759b31"></div>

    <div class="inner">
      <div class="title">Arch LinuxでESP32の環境を構築(Arduino IDE)</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-09-02T03:51:18JST">2018-09-02</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/ros-lunar_on_arch/">
    <div class="thumb thumb-984758970a7a9b13be2dda2245b55bc0"></div>

    <div class="inner">
      <div class="title">Arch LinuxでROS Lunarを使う</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-04-30T21:48:13JST">2018-04-30</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/latex_transpose/">
    <div class="thumb thumb-affad8b4c9b1dc4313a19d1a3dba7cea"></div>

    <div class="inner">
      <div class="title">LaTeXでの転置行列の表記</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-01-14T00:50:09JST">2018-01-14</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/rviz_invalid_quaternion/">
    <div class="thumb thumb-196f35a41629edee268871118953dad4"></div>

    <div class="inner">
      <div class="title">rvizとquaternion</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-01-02T00:09:13JST">2018-01-02</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/how_to_use_urg/">
    <div class="thumb thumb-f7718d298b384f1f0a1853ab9f589a3c"></div>

    <div class="inner">
      <div class="title">URG使い方</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2018-01-01T21:25:44JST">2018-01-01</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
      <article class="lism">
  <a href="https://blog.browniealice.net/post/mail_server/">
    <div class="thumb thumb-a2cb24d7c92e2209de12daee99c91cee"></div>

    <div class="inner">
      <div class="title">メールサーバを運用し始めた</div>

      <ul class="facts sm">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2017-12-10T17:42:44JST">2017-12-10</time></li>
        <li><i class="fa fa-bookmark" aria-hidden="true"></i>POST</li>
        
      </ul>

    </div>
  </a>
</article>

      
    </div>
  </div>
</section>

    
<section class="sidebar">
  <header>CATEGORIES</header>
  <div>
    <ul class="terms">
      <li><a href="https://blog.browniealice.net/categories/diary">diary <span class="count">(9)</span></a></li><li><a href="https://blog.browniealice.net/categories/technote">technote <span class="count">(8)</span></a></li><li><a href="https://blog.browniealice.net/categories/travel">travel <span class="count">(4)</span></a></li>
    </ul>
  </div>
</section>



    
<section class="sidebar">
  <header>TAGS</header>
  <div>
    <ul class="terms">
      <li><a href="https://blog.browniealice.net/tags/hugo">hugo <span class="count">(3)</span></a></li><li><a href="https://blog.browniealice.net/tags/pilgrimage">pilgrimage <span class="count">(3)</span></a></li><li><a href="https://blog.browniealice.net/tags/ros">ros <span class="count">(3)</span></a></li><li><a href="https://blog.browniealice.net/tags/c&#43;&#43;">c&#43;&#43; <span class="count">(2)</span></a></li><li><a href="https://blog.browniealice.net/tags/robocon">robocon <span class="count">(2)</span></a></li><li><a href="https://blog.browniealice.net/tags/server">server <span class="count">(2)</span></a></li><li><a href="https://blog.browniealice.net/tags/esp32">esp32 <span class="count">(1)</span></a></li><li><a href="https://blog.browniealice.net/tags/internship">internship <span class="count">(1)</span></a></li><li><a href="https://blog.browniealice.net/tags/labo">labo <span class="count">(1)</span></a></li><li><a href="https://blog.browniealice.net/tags/latex">latex <span class="count">(1)</span></a></li>
    </ul>
  </div>
</section>



    
<section class="sidebar">
  <header>SERIES</header>
  <div>
    <ul class="terms">
      <li><a href="https://blog.browniealice.net/series/%E9%87%91%E6%B2%A2%E8%81%96%E5%9C%B0%E5%B7%A1%E7%A4%BC">金沢聖地巡礼 <span class="count">(3)</span></a></li>
    </ul>
  </div>
</section>



  </div>

</aside>

  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="l-container">
        <p>Copyright &copy; 2017-2019, BrownieAlice.<br>
<a rel='license' href='http://creativecommons.org/licenses/by-sa/4.0/'>
<img alt='クリエイティブ・コモンズ・ライセンス' style='border-width:0' src='https://i.creativecommons.org/l/by-sa/4.0/80x15.png' />
</a><br>
このサイトのテキストは原則として
<a rel='license' href='http://creativecommons.org/licenses/by-sa/4.0/'>クリエイティブ・コモンズ 表示 - 継承 4.0 国際 ライセンス</a>
の下に提供されています.</p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_robust">Robust</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

